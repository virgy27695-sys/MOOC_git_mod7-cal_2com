const chalk = require("chalk");
const error = chalk.bgRed;
const info = chalk.green;
const ask = chalk.bgCyan;
const suiteTitle = chalk.yellow.inverse;
const testTitle = chalk.bgGreen;
const highlight = chalk.green;
const blueinfo = chalk.bgBlue;

//métodos de los custom reporters https://github.com/facebook/jest/blob/main/packages/jest-reporters/src/types.ts
class CustomReporter {
  /* reporter options es lo que se pasa en el configuracion de jest { banana: 'yes', pineapple: 'no' } */
  constructor(globalConfig, reporterOptions, reporterContext) {
    this._globalConfig = globalConfig;
    this._options = reporterOptions; 
    this._context = reporterContext;    
  }

onRunStart(test) {
    this._numTestSuitesLeft = test.numTotalTestSuites;
    console.log()
    console.log(`${suiteTitle("EJECUTANDO EL TEST-SUITE DE LA PRÁCTICA")}\n`);
}

onRunComplete(test, results) {
  try{
    global.debug('Terminado de ejecutar el test-suite');
    const {
      numFailedTests,
      numPassedTests,
      numTodoTests,
      numPendingTests,
      testResults,
      numTotalTests,
      startTime
    } = results;

    console.log();
    testResults.map(({failureMessage}) => {
        if (failureMessage) {
            global.debug("MENSAJE DE FALLO DE JEST:");
            global.debug(failureMessage);
        }
    });

    console.log(`Ejecutados ${numTotalTests} tests en ${testDuration()}`);
    process.stdout.write(` ${numPassedTests || 0} pasan`);
    process.stdout.write(` ${numFailedTests || 0} fallan`);
    console.log();  

    function testDuration() {
        const end = new Date();
        const start = new Date(startTime);

        const seconds = (end - start) / 1000;
        return `${seconds} s`;
    }
  } catch (error) {
    console.log(error);
  }
}

/* Este método se llama al ejecutar cada test case
Recibe dos parámetros test y testCaseResult
test contiene configuracion
testCaseResult los resultados de la ejecucion */
onTestCaseResult(test, testCaseResult) {
  try{
    let myinfo = JSON.parse(testCaseResult.title);
    //global.debug("TEST RESULT: ", testCaseResult);
    if (testCaseResult.status === "failed") {
      console.log(`${testTitle("TEST CASE REPORT:")}`);
      console.log(`${info("NOMBRE:")} ${myinfo.name}`); 
      console.log(`${info("ESTADO:")} ${error("FAILED")}`);
      console.log(`${info("REALIMENTACIÓN:")} ${myinfo.msg_error}`);
      console.log(`${info("PUNTUACION:")} 0`);
      console.log(`${info("ERROR PRODUCIDO:")}`);
      console.log("Lea detenidamente el error y vea en qué línea del test se ha producido y que valor se esperaba.");
      console.log(testCaseResult.failureMessages[0]);
      console.log(`${blueinfo("--------------------------------------------------------------------------------")}`);
    } else if (testCaseResult.status === "passed") {
      console.log(`${testTitle("TEST CASE REPORT:")}`);
      console.log(`${info("NOMBRE:")} ${myinfo.name}`); 
      console.log(`${info("ESTADO:")} ${testTitle("PASSED")}`);
      console.log(`${info("REALIMENTACIÓN:")} ${myinfo.msg_ok}`);
      console.log(`${info("PUNTUACION:")} ${info(myinfo.score)}`);
      console.log(`${blueinfo("--------------------------------------------------------------------------------")}`);
    } else {
      console.log(`${testTitle("TEST CASE")} ${myinfo.name} has status ${info(testCaseResult.status)}`);
    }
  } catch (error) {
    console.log(error);
  }
}

/* Este método se llama al ejecutar todo el test-suite
Recibe dos parámetros test y testResult
test contiene configuracion
testResult los resultados de la ejecucion */
/*
onTestResult(test, testResult) {
  //global.debug("TEST RESULT: ", testResult);
      for (var i = 0; i < testResult.testResults.length; i++) {
          switch (testResult.testResults[i].status) {
              case "passed":
                  process.stdout.write(".")
                  break
              case "skipped":
              case "pending":
              case "todo":
              case "disabled":
                  process.stdout.write("*")
                  break
              case "failed":
                  process.stdout.write("F")
                  break
              default:
                  process.stdout.write(`(${testResult.testResults[i].status})`)
          }
      }
}
*/

  // Optionally, reporters can force Jest to exit with non zero code by returning
  // an `Error` from `getLastError()` method.
  getLastError() {
    if (this._shouldFail) {
      return new Error('Custom error reported!. No debería pasar por aquí.');
    }
  }
}

module.exports = CustomReporter;